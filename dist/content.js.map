{
  "version": 3,
  "sources": [
    "../node_modules/esnow/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "../content.js",
    "../node_modules/cat-names/cat-names.json",
    "../node_modules/cat-names/index.js",
    "../node_modules/cat-names/node_modules/unique-random-array/index.js",
    "../node_modules/cat-names/node_modules/unique-random-array/node_modules/unique-random/index.js",
    "../node_modules/esnow/node_modules/browserify/node_modules/os-browserify/browser.js",
    "../node_modules/lorem-ipsum/lib/dictionary.js",
    "../node_modules/lorem-ipsum/lib/generator.js",
    "../node_modules/mutation-summary/src/mutation-summary.js"
  ],
  "names": [],
  "mappings": "AAAA;;;;;;;wBCAqB,WAAW;;;;0BACd,aAAa;;;;+BACH,kBAAkB;;;;AAE9C,IAAM,QAAQ,GAAG,CACf,QAAQ,EACR,MAAM,EACN,iBAAiB,EACjB,MAAM,EACN,OAAO,EACP,SAAS,EACT,SAAS,EACT,QAAQ,EACR,SAAS,EACT,MAAM,EACN,OAAO,EACP,MAAM,CACP,CAAC;;;AAGF,IAAM,iBAAiB,GAAG,CACxB,uBAAuB,EACvB,aAAa,EACb,iBAAiB,CAClB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACb,IAAM,cAAc,GAAG,CACrB,SAAS,EACT,kBAAkB,EAClB,gBAAgB,CACjB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACb,IAAM,cAAc,GAAG,CACrB,SAAS,EACT,0BAA0B,CAC3B,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACb,IAAM,eAAe,GAAG,CACtB,mBAAmB,EACnB,+BAA+B,CAChC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;;AAEb,SAAS,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;AACzB,sCAAkC,CAAC,SAAI,CAAC,eAAU,CAAC,CAAG;CACvD;;AAED,SAAS,YAAY,CAAC,EAAE,EAAE,KAAK,EAAE,OAAO,EAAE;AACxC,MAAM,UAAU,GAAG,EAAE,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;;AAE1D,+BAAI,UAAU,GAAE,OAAO,CAAC,UAAC,SAAS,EAAK;AACrC,QAAM,MAAM,GAAG,SAAS,CAAC,gBAAgB,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7D,QAAM,MAAM,GAAG,SAAS,CAAC,gBAAgB,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7D,QAAM,QAAQ,GAAG,SAAS,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;;AAE7D,QAAI,CAAC,MAAM,EAAE,OAAO;;AAEpB,QAAM,QAAQ,GAAG,MAAM,CAAC,WAAW,IAAI,MAAM,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC;;AAEzE,QAAI,QAAQ,IAAI,OAAO,EAAE;AACvB,UAAM,KAAK,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;AAChC,YAAM,CAAC,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC;;AAEhC,UAAI,MAAM,EAAE;AACV,cAAM,CAAC,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;OACxD;;AAED,UAAI,QAAQ,IAAI,KAAK,CAAC,WAAW,EAAE;AACjC,UAAE,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,UAAC,OAAO,EAAK;AACrC,iBAAO,CAAC,WAAW,GAAG,6BAAM,EAAC,KAAK,EAAE,YAAY,EAAE,KAAK,EAAE,QAAQ,EAAC,CAAC,CAAC;SACrE,CAAC,CAAC;OACJ;KACF;GACF,CAAC,CAAC;CACJ;;AAED,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,UAAC,KAAK,EAAK;AACxC,MAAM,OAAO,GAAG,EAAE,CAAC;;;;;;;AAEnB,yBAAgB,KAAK,CAAC,KAAK,8HAAE;UAAlB,CAAC;;AACV,UAAM,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC;AAC7C,UAAM,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;;AAEtC,aAAO,CAAC,CAAC,CAAC,GAAG;AACX,YAAI,EAAE,sBAAS,MAAM,EAAE;AACvB,cAAM,EAAN,MAAM;OACP,CAAC;KACH;;;;;;;;;;;;;;;;AAED,cAAY,CAAC,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;;AAEvC,MAAM,IAAI,GAAG,QAAQ,CAAC,aAAa,CAAC,uBAAuB,CAAC,CAAC;;AAE7D,MAAI,IAAI,EAAE;AACR,sCAAgB,EAAC,QAAQ,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC,EAAC,GAAG,EAAE,IAAI,EAAC,CAAC,EAAE,QAAQ,EAAE,kBAAC,SAAS,EAAK;AAChF,YAAM,OAAO,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;AAC7B,eAAO,CAAC,KAAK,CAAC,OAAO,CAAC,UAAC,EAAE,EAAK;AAC5B,cAAI,EAAE,CAAC,UAAU,KAAK,IAAI,IAAI,EAAE,CAAC,gBAAgB,EAAE;AACjD,wBAAY,CAAC,EAAE,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;WAClC;SACF,CAAC,CAAC;OACJ,EAAC,CAAC,CAAC;GACL;CACF,CAAC,CAAC;;;ACnGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "import catNames from 'cat-names';\nimport lorem from 'lorem-ipsum';\nimport mutationSummary from 'mutation-summary';\n\nconst catWords = [\n  'meooow',\n  'meow',\n  'scratching post',\n  'naww',\n  'purrr',\n  'meeeeow',\n  'kibbles',\n  'cuddle',\n  'snuggle',\n  'purr',\n  'nyaaa',\n  'nyan',\n];\n\n// Selectors.\nconst containerSelector = [\n  '.js-comment-container',\n  '.issue-meta',\n  '.gh-header-meta',\n].join(', ');\nconst authorSelector = [\n  '.author',\n  '.author-name > a',\n  '.opened-by > a',\n].join(', ');\nconst avatarSelector = [\n  '.avatar',\n  '.timeline-comment-avatar',\n].join(', ');\nconst commentSelector = [\n  '.comment-body > p',\n  '.comment-body .email-fragment',\n].join(', ');\n\nfunction catPhoto(n, w, h) {\n  return `https://placekitten.com/${w}/${h}?image=${n}`;\n}\n\nfunction replaceUsers(el, store, userMap) {\n  const containers = el.querySelectorAll(containerSelector);\n\n  [...containers].forEach((container) => {\n    const author = container.querySelectorAll(authorSelector)[0];\n    const avatar = container.querySelectorAll(avatarSelector)[0];\n    const comments = container.querySelectorAll(commentSelector);\n\n    if (!author) return;\n\n    const username = author.textContent || author.getAttribute('aria-label');\n\n    if (username in userMap) {\n      const uData = userMap[username];\n      author.textContent = uData.name;\n\n      if (avatar) {\n        avatar.src = uData.avatar(avatar.width, avatar.height);\n      }\n\n      if (comments && store.replaceText) {\n        [].forEach.call(comments, (comment) => {\n          comment.textContent = lorem({units: 'paragraphs', words: catWords});\n        });\n      }\n    }\n  });\n}\n\nchrome.storage.local.get(null, (store) => {\n  const userMap = {};\n\n  for (const u of store.users) {\n    const n = Math.floor(Math.random() * 15) + 1;\n    const avatar = catPhoto.bind(null, n);\n\n    userMap[u] = {\n      name: catNames.random(),\n      avatar,\n    };\n  }\n\n  replaceUsers(document, store, userMap);\n\n  const pjax = document.querySelector('[data-pjax-container]');\n\n  if (pjax) {\n    mutationSummary({rootNode: pjax, queries: [{all: true}], callback: (summaries) => {\n      const summary = summaries[0];\n      summary.added.forEach((el) => {\n        if (el.parentNode === pjax && el.querySelectorAll) {\n          replaceUsers(el, store, userMap);\n        }\n      });\n    }});\n  }\n});\n",
    "module.exports=[\n\t\"Abby\",\n\t\"Angel\",\n\t\"Annie\",\n\t\"Baby\",\n\t\"Bailey\",\n\t\"Bandit\",\n\t\"Bear\",\n\t\"Bella\",\n\t\"Bob\",\n\t\"Boo\",\n\t\"Boots\",\n\t\"Bubba\",\n\t\"Buddy\",\n\t\"Buster\",\n\t\"Cali\",\n\t\"Callie\",\n\t\"Casper\",\n\t\"Charlie\",\n\t\"Chester\",\n\t\"Chloe\",\n\t\"Cleo\",\n\t\"Coco\",\n\t\"Cookie\",\n\t\"Cuddles\",\n\t\"Daisy\",\n\t\"Dusty\",\n\t\"Felix\",\n\t\"Fluffy\",\n\t\"Garfield\",\n\t\"George\",\n\t\"Ginger\",\n\t\"Gizmo\",\n\t\"Gracie\",\n\t\"Harley\",\n\t\"Jack\",\n\t\"Jasmine\",\n\t\"Jasper\",\n\t\"Kiki\",\n\t\"Kitty\",\n\t\"Leo\",\n\t\"Lilly\",\n\t\"Lily\",\n\t\"Loki\",\n\t\"Lola\",\n\t\"Lucky\",\n\t\"Lucy\",\n\t\"Luna\",\n\t\"Maggie\",\n\t\"Max\",\n\t\"Mia\",\n\t\"Midnight\",\n\t\"Milo\",\n\t\"Mimi\",\n\t\"Miss kitty\",\n\t\"Missy\",\n\t\"Misty\",\n\t\"Mittens\",\n\t\"Molly\",\n\t\"Muffin\",\n\t\"Nala\",\n\t\"Oliver\",\n\t\"Oreo\",\n\t\"Oscar\",\n\t\"Patches\",\n\t\"Peanut\",\n\t\"Pepper\",\n\t\"Precious\",\n\t\"Princess\",\n\t\"Pumpkin\",\n\t\"Rascal\",\n\t\"Rocky\",\n\t\"Sadie\",\n\t\"Salem\",\n\t\"Sam\",\n\t\"Samantha\",\n\t\"Sammy\",\n\t\"Sasha\",\n\t\"Sassy\",\n\t\"Scooter\",\n\t\"Shadow\",\n\t\"Sheba\",\n\t\"Simba\",\n\t\"Simon\",\n\t\"Smokey\",\n\t\"Snickers\",\n\t\"Snowball\",\n\t\"Snuggles\",\n\t\"Socks\",\n\t\"Sophie\",\n\t\"Spooky\",\n\t\"Sugar\",\n\t\"Tiger\",\n\t\"Tigger\",\n\t\"Tinkerbell\",\n\t\"Toby\",\n\t\"Trouble\",\n\t\"Whiskers\",\n\t\"Willow\",\n\t\"Zoe\",\n\t\"Zoey\"\n]\n",
    "'use strict';\nvar uniqueRandomArray = require('unique-random-array');\nvar catNames = require('./cat-names.json');\n\nexports.all = catNames;\nexports.random = uniqueRandomArray(catNames);\n",
    "'use strict';\nvar uniqueRandom = require('unique-random');\n\nmodule.exports = function (arr) {\n\tvar rand = uniqueRandom(0, arr.length - 1);\n\n\treturn function () {\n\t\treturn arr[rand()];\n\t};\n};\n",
    "'use strict';\nmodule.exports = function (min, max) {\n\tvar prev;\n\treturn function rand() {\n\t\tvar num = Math.floor(Math.random() * (max - min + 1) + min);\n\t\treturn prev = num === prev && min !== max ? rand() : num;\n\t};\n};\n",
    "exports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n",
    "var dictionary = {\n  words: [\n    'ad',\n    'adipisicing',\n    'aliqua',\n    'aliquip',\n    'amet',\n    'anim',\n    'aute',\n    'cillum',\n    'commodo',\n    'consectetur',\n    'consequat',\n    'culpa',\n    'cupidatat',\n    'deserunt',\n    'do',\n    'dolor',\n    'dolore',\n    'duis',\n    'ea',\n    'eiusmod',\n    'elit',\n    'enim',\n    'esse',\n    'est',\n    'et',\n    'eu',\n    'ex',\n    'excepteur',\n    'exercitation',\n    'fugiat',\n    'id',\n    'in',\n    'incididunt',\n    'ipsum',\n    'irure',\n    'labore',\n    'laboris',\n    'laborum',\n    'Lorem',\n    'magna',\n    'minim',\n    'mollit',\n    'nisi',\n    'non',\n    'nostrud',\n    'nulla',\n    'occaecat',\n    'officia',\n    'pariatur',\n    'proident',\n    'qui',\n    'quis',\n    'reprehenderit',\n    'sint',\n    'sit',\n    'sunt',\n    'tempor',\n    'ullamco',\n    'ut',\n    'velit',\n    'veniam',\n    'voluptate'  \n  ]\n};\n\nmodule.exports = dictionary;",
    "var generator = function() {\n  var options = (arguments.length) ? arguments[0] : {}\n    , count = options.count || 1\n    , units = options.units || 'sentences'\n    , sentenceLowerBound = options.sentenceLowerBound || 5\n    , sentenceUpperBound = options.sentenceUpperBound || 15\n\t  , paragraphLowerBound = options.paragraphLowerBound || 3\n\t  , paragraphUpperBound = options.paragraphUpperBound || 7\n\t  , format = options.format || 'plain'\n    , words = options.words || require('./dictionary').words\n    , random = options.random || Math.random\n    , suffix = options.suffix || require('os').EOL;\n\n  units = simplePluralize(units.toLowerCase());\n\n  var randomInteger = function(min, max) {\n    return Math.floor(random() * (max - min + 1) + min);\n  };\n\n  var randomWord = function(words) {\n    return words[randomInteger(0, words.length - 1)];\n  };\n\n  var randomSentence = function(words, lowerBound, upperBound) {\n    var sentence = ''\n      , bounds = {min: 0, max: randomInteger(lowerBound, upperBound)};\n\n    while (bounds.min < bounds.max) {\n      sentence = sentence + ' ' + randomWord(words);\n      bounds.min = bounds.min + 1;\n    }\n\n    if (sentence.length) {\n      sentence = sentence.slice(1);\n      sentence = sentence.charAt(0).toUpperCase() + sentence.slice(1);\n    }\n\n    return sentence;\n  };\n\n  var randomParagraph = function(words, lowerBound, upperBound, sentenceLowerBound, sentenceUpperBound) {\n    var paragraph = ''\n      , bounds = {min: 0, max: randomInteger(lowerBound, upperBound)};\n\n    while (bounds.min < bounds.max) {\n      paragraph = paragraph + '. ' + randomSentence(words, sentenceLowerBound, sentenceUpperBound);\n      bounds.min = bounds.min + 1;\n    }\n\n    if (paragraph.length) {\n      paragraph = paragraph.slice(2);\n      paragraph = paragraph + '.';\n    }\n\n    return paragraph;\n  }\n\n  var iter = 0\n    , bounds = {min: 0, max: count}\n    , string = ''\n    , prefix = '';\n\n  if (format == 'html') {\n    openingTag = '<p>';\n    closingTag = '</p>';\n  }\n\n  while (bounds.min < bounds.max) {\n    switch (units.toLowerCase()) {\n      case 'words':\n        string = string + ' ' + randomWord(words);\n        break;\n      case 'sentences':\n        string = string + '. ' + randomSentence(words, sentenceLowerBound, sentenceUpperBound);\n        break;\n      case 'paragraphs':\n        var nextString = randomParagraph(words, paragraphLowerBound, paragraphUpperBound, sentenceLowerBound, sentenceUpperBound);\n\n        if (format == 'html') {\n          nextString = openingTag + nextString + closingTag;\n          if (bounds.min < bounds.max - 1) {\n            nextString = nextString + suffix; // Each paragraph on a new line\n          }\n        } else if (bounds.min < bounds.max - 1) {\n          nextString = nextString + suffix + suffix; // Double-up the EOL character to make distinct paragraphs, like carriage return\n        }\n\n        string = string + nextString;\n\n        break;\n    }\n\n    bounds.min = bounds.min + 1;\n  }\n\n  if (string.length) {\n    var pos = 0;\n\n    if (string.indexOf('. ') == 0) {\n      pos = 2;\n    } else if (string.indexOf('.') == 0 || string.indexOf(' ') == 0) {\n      pos = 1;\n    }\n\n    string = string.slice(pos);\n\n    if (units == 'sentences') {\n      string = string + '.';\n    }\n  }\n\n  return string;\n};\n\nfunction simplePluralize(string) {\n  if (string.indexOf('s', string.length - 1) === -1) {\n    return string + 's';\n  }\n  return string;\n}\n\nmodule.exports = generator;\n",
    "// Copyright 2011 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar MutationObserverCtor;\nif (typeof WebKitMutationObserver !== 'undefined')\n    MutationObserverCtor = WebKitMutationObserver;\nelse\n    MutationObserverCtor = MutationObserver;\n\nif (MutationObserverCtor === undefined) {\n    console.error('DOM Mutation Observers are required.');\n    console.error('https://developer.mozilla.org/en-US/docs/DOM/MutationObserver');\n    throw Error('DOM Mutation Observers are required');\n}\n\nvar NodeMap = (function () {\n    function NodeMap() {\n        this.nodes = [];\n        this.values = [];\n    }\n    NodeMap.prototype.isIndex = function (s) {\n        return +s === s >>> 0;\n    };\n\n    NodeMap.prototype.nodeId = function (node) {\n        var id = node[NodeMap.ID_PROP];\n        if (!id)\n            id = node[NodeMap.ID_PROP] = NodeMap.nextId_++;\n        return id;\n    };\n\n    NodeMap.prototype.set = function (node, value) {\n        var id = this.nodeId(node);\n        this.nodes[id] = node;\n        this.values[id] = value;\n    };\n\n    NodeMap.prototype.get = function (node) {\n        var id = this.nodeId(node);\n        return this.values[id];\n    };\n\n    NodeMap.prototype.has = function (node) {\n        return this.nodeId(node) in this.nodes;\n    };\n\n    NodeMap.prototype.delete = function (node) {\n        var id = this.nodeId(node);\n        delete this.nodes[id];\n        this.values[id] = undefined;\n    };\n\n    NodeMap.prototype.keys = function () {\n        var nodes = [];\n        for (var id in this.nodes) {\n            if (!this.isIndex(id))\n                continue;\n            nodes.push(this.nodes[id]);\n        }\n\n        return nodes;\n    };\n    NodeMap.ID_PROP = '__mutation_summary_node_map_id__';\n    NodeMap.nextId_ = 1;\n    return NodeMap;\n})();\n\n/**\n*  var reachableMatchableProduct = [\n*  //  STAYED_OUT,  ENTERED,     STAYED_IN,   EXITED\n*    [ STAYED_OUT,  STAYED_OUT,  STAYED_OUT,  STAYED_OUT ], // STAYED_OUT\n*    [ STAYED_OUT,  ENTERED,     ENTERED,     STAYED_OUT ], // ENTERED\n*    [ STAYED_OUT,  ENTERED,     STAYED_IN,   EXITED     ], // STAYED_IN\n*    [ STAYED_OUT,  STAYED_OUT,  EXITED,      EXITED     ]  // EXITED\n*  ];\n*/\nvar Movement;\n(function (Movement) {\n    Movement[Movement[\"STAYED_OUT\"] = 0] = \"STAYED_OUT\";\n    Movement[Movement[\"ENTERED\"] = 1] = \"ENTERED\";\n    Movement[Movement[\"STAYED_IN\"] = 2] = \"STAYED_IN\";\n    Movement[Movement[\"REPARENTED\"] = 3] = \"REPARENTED\";\n    Movement[Movement[\"REORDERED\"] = 4] = \"REORDERED\";\n    Movement[Movement[\"EXITED\"] = 5] = \"EXITED\";\n})(Movement || (Movement = {}));\n\nfunction enteredOrExited(changeType) {\n    return changeType === 1 /* ENTERED */ || changeType === 5 /* EXITED */;\n}\n\nvar NodeChange = (function () {\n    function NodeChange(node, childList, attributes, characterData, oldParentNode, added, attributeOldValues, characterDataOldValue) {\n        if (typeof childList === \"undefined\") { childList = false; }\n        if (typeof attributes === \"undefined\") { attributes = false; }\n        if (typeof characterData === \"undefined\") { characterData = false; }\n        if (typeof oldParentNode === \"undefined\") { oldParentNode = null; }\n        if (typeof added === \"undefined\") { added = false; }\n        if (typeof attributeOldValues === \"undefined\") { attributeOldValues = null; }\n        if (typeof characterDataOldValue === \"undefined\") { characterDataOldValue = null; }\n        this.node = node;\n        this.childList = childList;\n        this.attributes = attributes;\n        this.characterData = characterData;\n        this.oldParentNode = oldParentNode;\n        this.added = added;\n        this.attributeOldValues = attributeOldValues;\n        this.characterDataOldValue = characterDataOldValue;\n        this.isCaseInsensitive = this.node.nodeType === Node.ELEMENT_NODE && this.node instanceof HTMLElement && this.node.ownerDocument instanceof HTMLDocument;\n    }\n    NodeChange.prototype.getAttributeOldValue = function (name) {\n        if (!this.attributeOldValues)\n            return undefined;\n        if (this.isCaseInsensitive)\n            name = name.toLowerCase();\n        return this.attributeOldValues[name];\n    };\n\n    NodeChange.prototype.getAttributeNamesMutated = function () {\n        var names = [];\n        if (!this.attributeOldValues)\n            return names;\n        for (var name in this.attributeOldValues) {\n            names.push(name);\n        }\n        return names;\n    };\n\n    NodeChange.prototype.attributeMutated = function (name, oldValue) {\n        this.attributes = true;\n        this.attributeOldValues = this.attributeOldValues || {};\n\n        if (name in this.attributeOldValues)\n            return;\n\n        this.attributeOldValues[name] = oldValue;\n    };\n\n    NodeChange.prototype.characterDataMutated = function (oldValue) {\n        if (this.characterData)\n            return;\n        this.characterData = true;\n        this.characterDataOldValue = oldValue;\n    };\n\n    // Note: is it possible to receive a removal followed by a removal. This\n    // can occur if the removed node is added to an non-observed node, that\n    // node is added to the observed area, and then the node removed from\n    // it.\n    NodeChange.prototype.removedFromParent = function (parent) {\n        this.childList = true;\n        if (this.added || this.oldParentNode)\n            this.added = false;\n        else\n            this.oldParentNode = parent;\n    };\n\n    NodeChange.prototype.insertedIntoParent = function () {\n        this.childList = true;\n        this.added = true;\n    };\n\n    // An node's oldParent is\n    //   -its present parent, if its parentNode was not changed.\n    //   -null if the first thing that happened to it was an add.\n    //   -the node it was removed from if the first thing that happened to it\n    //      was a remove.\n    NodeChange.prototype.getOldParent = function () {\n        if (this.childList) {\n            if (this.oldParentNode)\n                return this.oldParentNode;\n            if (this.added)\n                return null;\n        }\n\n        return this.node.parentNode;\n    };\n    return NodeChange;\n})();\n\nvar ChildListChange = (function () {\n    function ChildListChange() {\n        this.added = new NodeMap();\n        this.removed = new NodeMap();\n        this.maybeMoved = new NodeMap();\n        this.oldPrevious = new NodeMap();\n        this.moved = undefined;\n    }\n    return ChildListChange;\n})();\n\nvar TreeChanges = (function (_super) {\n    __extends(TreeChanges, _super);\n    function TreeChanges(rootNode, mutations) {\n        _super.call(this);\n\n        this.rootNode = rootNode;\n        this.reachableCache = undefined;\n        this.wasReachableCache = undefined;\n        this.anyParentsChanged = false;\n        this.anyAttributesChanged = false;\n        this.anyCharacterDataChanged = false;\n\n        for (var m = 0; m < mutations.length; m++) {\n            var mutation = mutations[m];\n            switch (mutation.type) {\n                case 'childList':\n                    this.anyParentsChanged = true;\n                    for (var i = 0; i < mutation.removedNodes.length; i++) {\n                        var node = mutation.removedNodes[i];\n                        this.getChange(node).removedFromParent(mutation.target);\n                    }\n                    for (var i = 0; i < mutation.addedNodes.length; i++) {\n                        var node = mutation.addedNodes[i];\n                        this.getChange(node).insertedIntoParent();\n                    }\n                    break;\n\n                case 'attributes':\n                    this.anyAttributesChanged = true;\n                    var change = this.getChange(mutation.target);\n                    change.attributeMutated(mutation.attributeName, mutation.oldValue);\n                    break;\n\n                case 'characterData':\n                    this.anyCharacterDataChanged = true;\n                    var change = this.getChange(mutation.target);\n                    change.characterDataMutated(mutation.oldValue);\n                    break;\n            }\n        }\n    }\n    TreeChanges.prototype.getChange = function (node) {\n        var change = this.get(node);\n        if (!change) {\n            change = new NodeChange(node);\n            this.set(node, change);\n        }\n        return change;\n    };\n\n    TreeChanges.prototype.getOldParent = function (node) {\n        var change = this.get(node);\n        return change ? change.getOldParent() : node.parentNode;\n    };\n\n    TreeChanges.prototype.getIsReachable = function (node) {\n        if (node === this.rootNode)\n            return true;\n        if (!node)\n            return false;\n\n        this.reachableCache = this.reachableCache || new NodeMap();\n        var isReachable = this.reachableCache.get(node);\n        if (isReachable === undefined) {\n            isReachable = this.getIsReachable(node.parentNode);\n            this.reachableCache.set(node, isReachable);\n        }\n        return isReachable;\n    };\n\n    // A node wasReachable if its oldParent wasReachable.\n    TreeChanges.prototype.getWasReachable = function (node) {\n        if (node === this.rootNode)\n            return true;\n        if (!node)\n            return false;\n\n        this.wasReachableCache = this.wasReachableCache || new NodeMap();\n        var wasReachable = this.wasReachableCache.get(node);\n        if (wasReachable === undefined) {\n            wasReachable = this.getWasReachable(this.getOldParent(node));\n            this.wasReachableCache.set(node, wasReachable);\n        }\n        return wasReachable;\n    };\n\n    TreeChanges.prototype.reachabilityChange = function (node) {\n        if (this.getIsReachable(node)) {\n            return this.getWasReachable(node) ? 2 /* STAYED_IN */ : 1 /* ENTERED */;\n        }\n\n        return this.getWasReachable(node) ? 5 /* EXITED */ : 0 /* STAYED_OUT */;\n    };\n    return TreeChanges;\n})(NodeMap);\n\nvar MutationProjection = (function () {\n    // TOOD(any)\n    function MutationProjection(rootNode, mutations, selectors, calcReordered, calcOldPreviousSibling) {\n        this.rootNode = rootNode;\n        this.mutations = mutations;\n        this.selectors = selectors;\n        this.calcReordered = calcReordered;\n        this.calcOldPreviousSibling = calcOldPreviousSibling;\n        this.treeChanges = new TreeChanges(rootNode, mutations);\n        this.entered = [];\n        this.exited = [];\n        this.stayedIn = new NodeMap();\n        this.visited = new NodeMap();\n        this.childListChangeMap = undefined;\n        this.characterDataOnly = undefined;\n        this.matchCache = undefined;\n\n        this.processMutations();\n    }\n    MutationProjection.prototype.processMutations = function () {\n        if (!this.treeChanges.anyParentsChanged && !this.treeChanges.anyAttributesChanged)\n            return;\n\n        var changedNodes = this.treeChanges.keys();\n        for (var i = 0; i < changedNodes.length; i++) {\n            this.visitNode(changedNodes[i], undefined);\n        }\n    };\n\n    MutationProjection.prototype.visitNode = function (node, parentReachable) {\n        if (this.visited.has(node))\n            return;\n\n        this.visited.set(node, true);\n\n        var change = this.treeChanges.get(node);\n        var reachable = parentReachable;\n\n        // node inherits its parent's reachability change unless\n        // its parentNode was mutated.\n        if ((change && change.childList) || reachable == undefined)\n            reachable = this.treeChanges.reachabilityChange(node);\n\n        if (reachable === 0 /* STAYED_OUT */)\n            return;\n\n        // Cache match results for sub-patterns.\n        this.matchabilityChange(node);\n\n        if (reachable === 1 /* ENTERED */) {\n            this.entered.push(node);\n        } else if (reachable === 5 /* EXITED */) {\n            this.exited.push(node);\n            this.ensureHasOldPreviousSiblingIfNeeded(node);\n        } else if (reachable === 2 /* STAYED_IN */) {\n            var movement = 2 /* STAYED_IN */;\n\n            if (change && change.childList) {\n                if (change.oldParentNode !== node.parentNode) {\n                    movement = 3 /* REPARENTED */;\n                    this.ensureHasOldPreviousSiblingIfNeeded(node);\n                } else if (this.calcReordered && this.wasReordered(node)) {\n                    movement = 4 /* REORDERED */;\n                }\n            }\n\n            this.stayedIn.set(node, movement);\n        }\n\n        if (reachable === 2 /* STAYED_IN */)\n            return;\n\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n            this.visitNode(child, reachable);\n        }\n    };\n\n    MutationProjection.prototype.ensureHasOldPreviousSiblingIfNeeded = function (node) {\n        if (!this.calcOldPreviousSibling)\n            return;\n\n        this.processChildlistChanges();\n\n        var parentNode = node.parentNode;\n        var nodeChange = this.treeChanges.get(node);\n        if (nodeChange && nodeChange.oldParentNode)\n            parentNode = nodeChange.oldParentNode;\n\n        var change = this.childListChangeMap.get(parentNode);\n        if (!change) {\n            change = new ChildListChange();\n            this.childListChangeMap.set(parentNode, change);\n        }\n\n        if (!change.oldPrevious.has(node)) {\n            change.oldPrevious.set(node, node.previousSibling);\n        }\n    };\n\n    MutationProjection.prototype.getChanged = function (summary, selectors, characterDataOnly) {\n        this.selectors = selectors;\n        this.characterDataOnly = characterDataOnly;\n\n        for (var i = 0; i < this.entered.length; i++) {\n            var node = this.entered[i];\n            var matchable = this.matchabilityChange(node);\n            if (matchable === 1 /* ENTERED */ || matchable === 2 /* STAYED_IN */)\n                summary.added.push(node);\n        }\n\n        var stayedInNodes = this.stayedIn.keys();\n        for (var i = 0; i < stayedInNodes.length; i++) {\n            var node = stayedInNodes[i];\n            var matchable = this.matchabilityChange(node);\n\n            if (matchable === 1 /* ENTERED */) {\n                summary.added.push(node);\n            } else if (matchable === 5 /* EXITED */) {\n                summary.removed.push(node);\n            } else if (matchable === 2 /* STAYED_IN */ && (summary.reparented || summary.reordered)) {\n                var movement = this.stayedIn.get(node);\n                if (summary.reparented && movement === 3 /* REPARENTED */)\n                    summary.reparented.push(node);\n                else if (summary.reordered && movement === 4 /* REORDERED */)\n                    summary.reordered.push(node);\n            }\n        }\n\n        for (var i = 0; i < this.exited.length; i++) {\n            var node = this.exited[i];\n            var matchable = this.matchabilityChange(node);\n            if (matchable === 5 /* EXITED */ || matchable === 2 /* STAYED_IN */)\n                summary.removed.push(node);\n        }\n    };\n\n    MutationProjection.prototype.getOldParentNode = function (node) {\n        var change = this.treeChanges.get(node);\n        if (change && change.childList)\n            return change.oldParentNode ? change.oldParentNode : null;\n\n        var reachabilityChange = this.treeChanges.reachabilityChange(node);\n        if (reachabilityChange === 0 /* STAYED_OUT */ || reachabilityChange === 1 /* ENTERED */)\n            throw Error('getOldParentNode requested on invalid node.');\n\n        return node.parentNode;\n    };\n\n    MutationProjection.prototype.getOldPreviousSibling = function (node) {\n        var parentNode = node.parentNode;\n        var nodeChange = this.treeChanges.get(node);\n        if (nodeChange && nodeChange.oldParentNode)\n            parentNode = nodeChange.oldParentNode;\n\n        var change = this.childListChangeMap.get(parentNode);\n        if (!change)\n            throw Error('getOldPreviousSibling requested on invalid node.');\n\n        return change.oldPrevious.get(node);\n    };\n\n    MutationProjection.prototype.getOldAttribute = function (element, attrName) {\n        var change = this.treeChanges.get(element);\n        if (!change || !change.attributes)\n            throw Error('getOldAttribute requested on invalid node.');\n\n        var value = change.getAttributeOldValue(attrName);\n        if (value === undefined)\n            throw Error('getOldAttribute requested for unchanged attribute name.');\n\n        return value;\n    };\n\n    MutationProjection.prototype.attributeChangedNodes = function (includeAttributes) {\n        if (!this.treeChanges.anyAttributesChanged)\n            return {};\n\n        var attributeFilter;\n        var caseInsensitiveFilter;\n        if (includeAttributes) {\n            attributeFilter = {};\n            caseInsensitiveFilter = {};\n            for (var i = 0; i < includeAttributes.length; i++) {\n                var attrName = includeAttributes[i];\n                attributeFilter[attrName] = true;\n                caseInsensitiveFilter[attrName.toLowerCase()] = attrName;\n            }\n        }\n\n        var result = {};\n        var nodes = this.treeChanges.keys();\n\n        for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n\n            var change = this.treeChanges.get(node);\n            if (!change.attributes)\n                continue;\n\n            if (2 /* STAYED_IN */ !== this.treeChanges.reachabilityChange(node) || 2 /* STAYED_IN */ !== this.matchabilityChange(node)) {\n                continue;\n            }\n\n            var element = node;\n            var changedAttrNames = change.getAttributeNamesMutated();\n            for (var j = 0; j < changedAttrNames.length; j++) {\n                var attrName = changedAttrNames[j];\n\n                if (attributeFilter && !attributeFilter[attrName] && !(change.isCaseInsensitive && caseInsensitiveFilter[attrName])) {\n                    continue;\n                }\n\n                var oldValue = change.getAttributeOldValue(attrName);\n                if (oldValue === element.getAttribute(attrName))\n                    continue;\n\n                if (caseInsensitiveFilter && change.isCaseInsensitive)\n                    attrName = caseInsensitiveFilter[attrName];\n\n                result[attrName] = result[attrName] || [];\n                result[attrName].push(element);\n            }\n        }\n\n        return result;\n    };\n\n    MutationProjection.prototype.getOldCharacterData = function (node) {\n        var change = this.treeChanges.get(node);\n        if (!change || !change.characterData)\n            throw Error('getOldCharacterData requested on invalid node.');\n\n        return change.characterDataOldValue;\n    };\n\n    MutationProjection.prototype.getCharacterDataChanged = function () {\n        if (!this.treeChanges.anyCharacterDataChanged)\n            return [];\n\n        var nodes = this.treeChanges.keys();\n        var result = [];\n        for (var i = 0; i < nodes.length; i++) {\n            var target = nodes[i];\n            if (2 /* STAYED_IN */ !== this.treeChanges.reachabilityChange(target))\n                continue;\n\n            var change = this.treeChanges.get(target);\n            if (!change.characterData || target.textContent == change.characterDataOldValue)\n                continue;\n\n            result.push(target);\n        }\n\n        return result;\n    };\n\n    MutationProjection.prototype.computeMatchabilityChange = function (selector, el) {\n        if (!this.matchCache)\n            this.matchCache = [];\n        if (!this.matchCache[selector.uid])\n            this.matchCache[selector.uid] = new NodeMap();\n\n        var cache = this.matchCache[selector.uid];\n        var result = cache.get(el);\n        if (result === undefined) {\n            result = selector.matchabilityChange(el, this.treeChanges.get(el));\n            cache.set(el, result);\n        }\n        return result;\n    };\n\n    MutationProjection.prototype.matchabilityChange = function (node) {\n        var _this = this;\n        // TODO(rafaelw): Include PI, CDATA?\n        // Only include text nodes.\n        if (this.characterDataOnly) {\n            switch (node.nodeType) {\n                case Node.COMMENT_NODE:\n                case Node.TEXT_NODE:\n                    return 2 /* STAYED_IN */;\n                default:\n                    return 0 /* STAYED_OUT */;\n            }\n        }\n\n        // No element filter. Include all nodes.\n        if (!this.selectors)\n            return 2 /* STAYED_IN */;\n\n        // Element filter. Exclude non-elements.\n        if (node.nodeType !== Node.ELEMENT_NODE)\n            return 0 /* STAYED_OUT */;\n\n        var el = node;\n\n        var matchChanges = this.selectors.map(function (selector) {\n            return _this.computeMatchabilityChange(selector, el);\n        });\n\n        var accum = 0 /* STAYED_OUT */;\n        var i = 0;\n\n        while (accum !== 2 /* STAYED_IN */ && i < matchChanges.length) {\n            switch (matchChanges[i]) {\n                case 2 /* STAYED_IN */:\n                    accum = 2 /* STAYED_IN */;\n                    break;\n                case 1 /* ENTERED */:\n                    if (accum === 5 /* EXITED */)\n                        accum = 2 /* STAYED_IN */;\n                    else\n                        accum = 1 /* ENTERED */;\n                    break;\n                case 5 /* EXITED */:\n                    if (accum === 1 /* ENTERED */)\n                        accum = 2 /* STAYED_IN */;\n                    else\n                        accum = 5 /* EXITED */;\n                    break;\n            }\n\n            i++;\n        }\n\n        return accum;\n    };\n\n    MutationProjection.prototype.getChildlistChange = function (el) {\n        var change = this.childListChangeMap.get(el);\n        if (!change) {\n            change = new ChildListChange();\n            this.childListChangeMap.set(el, change);\n        }\n\n        return change;\n    };\n\n    MutationProjection.prototype.processChildlistChanges = function () {\n        if (this.childListChangeMap)\n            return;\n\n        this.childListChangeMap = new NodeMap();\n\n        for (var i = 0; i < this.mutations.length; i++) {\n            var mutation = this.mutations[i];\n            if (mutation.type != 'childList')\n                continue;\n\n            if (this.treeChanges.reachabilityChange(mutation.target) !== 2 /* STAYED_IN */ && !this.calcOldPreviousSibling)\n                continue;\n\n            var change = this.getChildlistChange(mutation.target);\n\n            var oldPrevious = mutation.previousSibling;\n\n            function recordOldPrevious(node, previous) {\n                if (!node || change.oldPrevious.has(node) || change.added.has(node) || change.maybeMoved.has(node))\n                    return;\n\n                if (previous && (change.added.has(previous) || change.maybeMoved.has(previous)))\n                    return;\n\n                change.oldPrevious.set(node, previous);\n            }\n\n            for (var j = 0; j < mutation.removedNodes.length; j++) {\n                var node = mutation.removedNodes[j];\n                recordOldPrevious(node, oldPrevious);\n\n                if (change.added.has(node)) {\n                    change.added.delete(node);\n                } else {\n                    change.removed.set(node, true);\n                    change.maybeMoved.delete(node);\n                }\n\n                oldPrevious = node;\n            }\n\n            recordOldPrevious(mutation.nextSibling, oldPrevious);\n\n            for (var j = 0; j < mutation.addedNodes.length; j++) {\n                var node = mutation.addedNodes[j];\n                if (change.removed.has(node)) {\n                    change.removed.delete(node);\n                    change.maybeMoved.set(node, true);\n                } else {\n                    change.added.set(node, true);\n                }\n            }\n        }\n    };\n\n    MutationProjection.prototype.wasReordered = function (node) {\n        if (!this.treeChanges.anyParentsChanged)\n            return false;\n\n        this.processChildlistChanges();\n\n        var parentNode = node.parentNode;\n        var nodeChange = this.treeChanges.get(node);\n        if (nodeChange && nodeChange.oldParentNode)\n            parentNode = nodeChange.oldParentNode;\n\n        var change = this.childListChangeMap.get(parentNode);\n        if (!change)\n            return false;\n\n        if (change.moved)\n            return change.moved.get(node);\n\n        change.moved = new NodeMap();\n        var pendingMoveDecision = new NodeMap();\n\n        function isMoved(node) {\n            if (!node)\n                return false;\n            if (!change.maybeMoved.has(node))\n                return false;\n\n            var didMove = change.moved.get(node);\n            if (didMove !== undefined)\n                return didMove;\n\n            if (pendingMoveDecision.has(node)) {\n                didMove = true;\n            } else {\n                pendingMoveDecision.set(node, true);\n                didMove = getPrevious(node) !== getOldPrevious(node);\n            }\n\n            if (pendingMoveDecision.has(node)) {\n                pendingMoveDecision.delete(node);\n                change.moved.set(node, didMove);\n            } else {\n                didMove = change.moved.get(node);\n            }\n\n            return didMove;\n        }\n\n        var oldPreviousCache = new NodeMap();\n        function getOldPrevious(node) {\n            var oldPrevious = oldPreviousCache.get(node);\n            if (oldPrevious !== undefined)\n                return oldPrevious;\n\n            oldPrevious = change.oldPrevious.get(node);\n            while (oldPrevious && (change.removed.has(oldPrevious) || isMoved(oldPrevious))) {\n                oldPrevious = getOldPrevious(oldPrevious);\n            }\n\n            if (oldPrevious === undefined)\n                oldPrevious = node.previousSibling;\n            oldPreviousCache.set(node, oldPrevious);\n\n            return oldPrevious;\n        }\n\n        var previousCache = new NodeMap();\n        function getPrevious(node) {\n            if (previousCache.has(node))\n                return previousCache.get(node);\n\n            var previous = node.previousSibling;\n            while (previous && (change.added.has(previous) || isMoved(previous)))\n                previous = previous.previousSibling;\n\n            previousCache.set(node, previous);\n            return previous;\n        }\n\n        change.maybeMoved.keys().forEach(isMoved);\n        return change.moved.get(node);\n    };\n    return MutationProjection;\n})();\n\nvar Summary = (function () {\n    function Summary(projection, query) {\n        var _this = this;\n        this.projection = projection;\n        this.added = [];\n        this.removed = [];\n        this.reparented = query.all || query.element ? [] : undefined;\n        this.reordered = query.all ? [] : undefined;\n\n        projection.getChanged(this, query.elementFilter, query.characterData);\n\n        if (query.all || query.attribute || query.attributeList) {\n            var filter = query.attribute ? [query.attribute] : query.attributeList;\n            var attributeChanged = projection.attributeChangedNodes(filter);\n\n            if (query.attribute) {\n                this.valueChanged = attributeChanged[query.attribute] || [];\n            } else {\n                this.attributeChanged = attributeChanged;\n                if (query.attributeList) {\n                    query.attributeList.forEach(function (attrName) {\n                        if (!_this.attributeChanged.hasOwnProperty(attrName))\n                            _this.attributeChanged[attrName] = [];\n                    });\n                }\n            }\n        }\n\n        if (query.all || query.characterData) {\n            var characterDataChanged = projection.getCharacterDataChanged();\n\n            if (query.characterData)\n                this.valueChanged = characterDataChanged;\n            else\n                this.characterDataChanged = characterDataChanged;\n        }\n\n        if (this.reordered)\n            this.getOldPreviousSibling = projection.getOldPreviousSibling.bind(projection);\n    }\n    Summary.prototype.getOldParentNode = function (node) {\n        return this.projection.getOldParentNode(node);\n    };\n\n    Summary.prototype.getOldAttribute = function (node, name) {\n        return this.projection.getOldAttribute(node, name);\n    };\n\n    Summary.prototype.getOldCharacterData = function (node) {\n        return this.projection.getOldCharacterData(node);\n    };\n\n    Summary.prototype.getOldPreviousSibling = function (node) {\n        return this.projection.getOldPreviousSibling(node);\n    };\n    return Summary;\n})();\n\n// TODO(rafaelw): Allow ':' and '.' as valid name characters.\nvar validNameInitialChar = /[a-zA-Z_]+/;\nvar validNameNonInitialChar = /[a-zA-Z0-9_\\-]+/;\n\n// TODO(rafaelw): Consider allowing backslash in the attrValue.\n// TODO(rafaelw): There's got a to be way to represent this state machine\n// more compactly???\nfunction escapeQuotes(value) {\n    return '\"' + value.replace(/\"/, '\\\\\\\"') + '\"';\n}\n\nvar Qualifier = (function () {\n    function Qualifier() {\n    }\n    Qualifier.prototype.matches = function (oldValue) {\n        if (oldValue === null)\n            return false;\n\n        if (this.attrValue === undefined)\n            return true;\n\n        if (!this.contains)\n            return this.attrValue == oldValue;\n\n        var tokens = oldValue.split(' ');\n        for (var i = 0; i < tokens.length; i++) {\n            if (this.attrValue === tokens[i])\n                return true;\n        }\n\n        return false;\n    };\n\n    Qualifier.prototype.toString = function () {\n        if (this.attrName === 'class' && this.contains)\n            return '.' + this.attrValue;\n\n        if (this.attrName === 'id' && !this.contains)\n            return '#' + this.attrValue;\n\n        if (this.contains)\n            return '[' + this.attrName + '~=' + escapeQuotes(this.attrValue) + ']';\n\n        if ('attrValue' in this)\n            return '[' + this.attrName + '=' + escapeQuotes(this.attrValue) + ']';\n\n        return '[' + this.attrName + ']';\n    };\n    return Qualifier;\n})();\n\nvar Selector = (function () {\n    function Selector() {\n        this.uid = Selector.nextUid++;\n        this.qualifiers = [];\n    }\n    Object.defineProperty(Selector.prototype, \"caseInsensitiveTagName\", {\n        get: function () {\n            return this.tagName.toUpperCase();\n        },\n        enumerable: true,\n        configurable: true\n    });\n\n    Object.defineProperty(Selector.prototype, \"selectorString\", {\n        get: function () {\n            return this.tagName + this.qualifiers.join('');\n        },\n        enumerable: true,\n        configurable: true\n    });\n\n    Selector.prototype.isMatching = function (el) {\n        return el[Selector.matchesSelector](this.selectorString);\n    };\n\n    Selector.prototype.wasMatching = function (el, change, isMatching) {\n        if (!change || !change.attributes)\n            return isMatching;\n\n        var tagName = change.isCaseInsensitive ? this.caseInsensitiveTagName : this.tagName;\n        if (tagName !== '*' && tagName !== el.tagName)\n            return false;\n\n        var attributeOldValues = [];\n        var anyChanged = false;\n        for (var i = 0; i < this.qualifiers.length; i++) {\n            var qualifier = this.qualifiers[i];\n            var oldValue = change.getAttributeOldValue(qualifier.attrName);\n            attributeOldValues.push(oldValue);\n            anyChanged = anyChanged || (oldValue !== undefined);\n        }\n\n        if (!anyChanged)\n            return isMatching;\n\n        for (var i = 0; i < this.qualifiers.length; i++) {\n            var qualifier = this.qualifiers[i];\n            var oldValue = attributeOldValues[i];\n            if (oldValue === undefined)\n                oldValue = el.getAttribute(qualifier.attrName);\n            if (!qualifier.matches(oldValue))\n                return false;\n        }\n\n        return true;\n    };\n\n    Selector.prototype.matchabilityChange = function (el, change) {\n        var isMatching = this.isMatching(el);\n        if (isMatching)\n            return this.wasMatching(el, change, isMatching) ? 2 /* STAYED_IN */ : 1 /* ENTERED */;\n        else\n            return this.wasMatching(el, change, isMatching) ? 5 /* EXITED */ : 0 /* STAYED_OUT */;\n    };\n\n    Selector.parseSelectors = function (input) {\n        var selectors = [];\n        var currentSelector;\n        var currentQualifier;\n\n        function newSelector() {\n            if (currentSelector) {\n                if (currentQualifier) {\n                    currentSelector.qualifiers.push(currentQualifier);\n                    currentQualifier = undefined;\n                }\n\n                selectors.push(currentSelector);\n            }\n            currentSelector = new Selector();\n        }\n\n        function newQualifier() {\n            if (currentQualifier)\n                currentSelector.qualifiers.push(currentQualifier);\n\n            currentQualifier = new Qualifier();\n        }\n\n        var WHITESPACE = /\\s/;\n        var valueQuoteChar;\n        var SYNTAX_ERROR = 'Invalid or unsupported selector syntax.';\n\n        var SELECTOR = 1;\n        var TAG_NAME = 2;\n        var QUALIFIER = 3;\n        var QUALIFIER_NAME_FIRST_CHAR = 4;\n        var QUALIFIER_NAME = 5;\n        var ATTR_NAME_FIRST_CHAR = 6;\n        var ATTR_NAME = 7;\n        var EQUIV_OR_ATTR_QUAL_END = 8;\n        var EQUAL = 9;\n        var ATTR_QUAL_END = 10;\n        var VALUE_FIRST_CHAR = 11;\n        var VALUE = 12;\n        var QUOTED_VALUE = 13;\n        var SELECTOR_SEPARATOR = 14;\n\n        var state = SELECTOR;\n        var i = 0;\n        while (i < input.length) {\n            var c = input[i++];\n\n            switch (state) {\n                case SELECTOR:\n                    if (c.match(validNameInitialChar)) {\n                        newSelector();\n                        currentSelector.tagName = c;\n                        state = TAG_NAME;\n                        break;\n                    }\n\n                    if (c == '*') {\n                        newSelector();\n                        currentSelector.tagName = '*';\n                        state = QUALIFIER;\n                        break;\n                    }\n\n                    if (c == '.') {\n                        newSelector();\n                        newQualifier();\n                        currentSelector.tagName = '*';\n                        currentQualifier.attrName = 'class';\n                        currentQualifier.contains = true;\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '#') {\n                        newSelector();\n                        newQualifier();\n                        currentSelector.tagName = '*';\n                        currentQualifier.attrName = 'id';\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '[') {\n                        newSelector();\n                        newQualifier();\n                        currentSelector.tagName = '*';\n                        currentQualifier.attrName = '';\n                        state = ATTR_NAME_FIRST_CHAR;\n                        break;\n                    }\n\n                    if (c.match(WHITESPACE))\n                        break;\n\n                    throw Error(SYNTAX_ERROR);\n\n                case TAG_NAME:\n                    if (c.match(validNameNonInitialChar)) {\n                        currentSelector.tagName += c;\n                        break;\n                    }\n\n                    if (c == '.') {\n                        newQualifier();\n                        currentQualifier.attrName = 'class';\n                        currentQualifier.contains = true;\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '#') {\n                        newQualifier();\n                        currentQualifier.attrName = 'id';\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '[') {\n                        newQualifier();\n                        currentQualifier.attrName = '';\n                        state = ATTR_NAME_FIRST_CHAR;\n                        break;\n                    }\n\n                    if (c.match(WHITESPACE)) {\n                        state = SELECTOR_SEPARATOR;\n                        break;\n                    }\n\n                    if (c == ',') {\n                        state = SELECTOR;\n                        break;\n                    }\n\n                    throw Error(SYNTAX_ERROR);\n\n                case QUALIFIER:\n                    if (c == '.') {\n                        newQualifier();\n                        currentQualifier.attrName = 'class';\n                        currentQualifier.contains = true;\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '#') {\n                        newQualifier();\n                        currentQualifier.attrName = 'id';\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '[') {\n                        newQualifier();\n                        currentQualifier.attrName = '';\n                        state = ATTR_NAME_FIRST_CHAR;\n                        break;\n                    }\n\n                    if (c.match(WHITESPACE)) {\n                        state = SELECTOR_SEPARATOR;\n                        break;\n                    }\n\n                    if (c == ',') {\n                        state = SELECTOR;\n                        break;\n                    }\n\n                    throw Error(SYNTAX_ERROR);\n\n                case QUALIFIER_NAME_FIRST_CHAR:\n                    if (c.match(validNameInitialChar)) {\n                        currentQualifier.attrValue = c;\n                        state = QUALIFIER_NAME;\n                        break;\n                    }\n\n                    throw Error(SYNTAX_ERROR);\n\n                case QUALIFIER_NAME:\n                    if (c.match(validNameNonInitialChar)) {\n                        currentQualifier.attrValue += c;\n                        break;\n                    }\n\n                    if (c == '.') {\n                        newQualifier();\n                        currentQualifier.attrName = 'class';\n                        currentQualifier.contains = true;\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '#') {\n                        newQualifier();\n                        currentQualifier.attrName = 'id';\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '[') {\n                        newQualifier();\n                        state = ATTR_NAME_FIRST_CHAR;\n                        break;\n                    }\n\n                    if (c.match(WHITESPACE)) {\n                        state = SELECTOR_SEPARATOR;\n                        break;\n                    }\n                    if (c == ',') {\n                        state = SELECTOR;\n                        break;\n                    }\n\n                    throw Error(SYNTAX_ERROR);\n\n                case ATTR_NAME_FIRST_CHAR:\n                    if (c.match(validNameInitialChar)) {\n                        currentQualifier.attrName = c;\n                        state = ATTR_NAME;\n                        break;\n                    }\n\n                    if (c.match(WHITESPACE))\n                        break;\n\n                    throw Error(SYNTAX_ERROR);\n\n                case ATTR_NAME:\n                    if (c.match(validNameNonInitialChar)) {\n                        currentQualifier.attrName += c;\n                        break;\n                    }\n\n                    if (c.match(WHITESPACE)) {\n                        state = EQUIV_OR_ATTR_QUAL_END;\n                        break;\n                    }\n\n                    if (c == '~') {\n                        currentQualifier.contains = true;\n                        state = EQUAL;\n                        break;\n                    }\n\n                    if (c == '=') {\n                        currentQualifier.attrValue = '';\n                        state = VALUE_FIRST_CHAR;\n                        break;\n                    }\n\n                    if (c == ']') {\n                        state = QUALIFIER;\n                        break;\n                    }\n\n                    throw Error(SYNTAX_ERROR);\n\n                case EQUIV_OR_ATTR_QUAL_END:\n                    if (c == '~') {\n                        currentQualifier.contains = true;\n                        state = EQUAL;\n                        break;\n                    }\n\n                    if (c == '=') {\n                        currentQualifier.attrValue = '';\n                        state = VALUE_FIRST_CHAR;\n                        break;\n                    }\n\n                    if (c == ']') {\n                        state = QUALIFIER;\n                        break;\n                    }\n\n                    if (c.match(WHITESPACE))\n                        break;\n\n                    throw Error(SYNTAX_ERROR);\n\n                case EQUAL:\n                    if (c == '=') {\n                        currentQualifier.attrValue = '';\n                        state = VALUE_FIRST_CHAR;\n                        break;\n                    }\n\n                    throw Error(SYNTAX_ERROR);\n\n                case ATTR_QUAL_END:\n                    if (c == ']') {\n                        state = QUALIFIER;\n                        break;\n                    }\n\n                    if (c.match(WHITESPACE))\n                        break;\n\n                    throw Error(SYNTAX_ERROR);\n\n                case VALUE_FIRST_CHAR:\n                    if (c.match(WHITESPACE))\n                        break;\n\n                    if (c == '\"' || c == \"'\") {\n                        valueQuoteChar = c;\n                        state = QUOTED_VALUE;\n                        break;\n                    }\n\n                    currentQualifier.attrValue += c;\n                    state = VALUE;\n                    break;\n\n                case VALUE:\n                    if (c.match(WHITESPACE)) {\n                        state = ATTR_QUAL_END;\n                        break;\n                    }\n                    if (c == ']') {\n                        state = QUALIFIER;\n                        break;\n                    }\n                    if (c == \"'\" || c == '\"')\n                        throw Error(SYNTAX_ERROR);\n\n                    currentQualifier.attrValue += c;\n                    break;\n\n                case QUOTED_VALUE:\n                    if (c == valueQuoteChar) {\n                        state = ATTR_QUAL_END;\n                        break;\n                    }\n\n                    currentQualifier.attrValue += c;\n                    break;\n\n                case SELECTOR_SEPARATOR:\n                    if (c.match(WHITESPACE))\n                        break;\n\n                    if (c == ',') {\n                        state = SELECTOR;\n                        break;\n                    }\n\n                    throw Error(SYNTAX_ERROR);\n            }\n        }\n\n        switch (state) {\n            case SELECTOR:\n            case TAG_NAME:\n            case QUALIFIER:\n            case QUALIFIER_NAME:\n            case SELECTOR_SEPARATOR:\n                // Valid end states.\n                newSelector();\n                break;\n            default:\n                throw Error(SYNTAX_ERROR);\n        }\n\n        if (!selectors.length)\n            throw Error(SYNTAX_ERROR);\n\n        return selectors;\n    };\n    Selector.nextUid = 1;\n    Selector.matchesSelector = (function () {\n        var element = document.createElement('div');\n        if (typeof element['webkitMatchesSelector'] === 'function')\n            return 'webkitMatchesSelector';\n        if (typeof element['mozMatchesSelector'] === 'function')\n            return 'mozMatchesSelector';\n        if (typeof element['msMatchesSelector'] === 'function')\n            return 'msMatchesSelector';\n\n        return 'matchesSelector';\n    })();\n    return Selector;\n})();\n\nvar attributeFilterPattern = /^([a-zA-Z:_]+[a-zA-Z0-9_\\-:\\.]*)$/;\n\nfunction validateAttribute(attribute) {\n    if (typeof attribute != 'string')\n        throw Error('Invalid request opion. attribute must be a non-zero length string.');\n\n    attribute = attribute.trim();\n\n    if (!attribute)\n        throw Error('Invalid request opion. attribute must be a non-zero length string.');\n\n    if (!attribute.match(attributeFilterPattern))\n        throw Error('Invalid request option. invalid attribute name: ' + attribute);\n\n    return attribute;\n}\n\nfunction validateElementAttributes(attribs) {\n    if (!attribs.trim().length)\n        throw Error('Invalid request option: elementAttributes must contain at least one attribute.');\n\n    var lowerAttributes = {};\n    var attributes = {};\n\n    var tokens = attribs.split(/\\s+/);\n    for (var i = 0; i < tokens.length; i++) {\n        var name = tokens[i];\n        if (!name)\n            continue;\n\n        var name = validateAttribute(name);\n        var nameLower = name.toLowerCase();\n        if (lowerAttributes[nameLower])\n            throw Error('Invalid request option: observing multiple case variations of the same attribute is not supported.');\n\n        attributes[name] = true;\n        lowerAttributes[nameLower] = true;\n    }\n\n    return Object.keys(attributes);\n}\n\nfunction elementFilterAttributes(selectors) {\n    var attributes = {};\n\n    selectors.forEach(function (selector) {\n        selector.qualifiers.forEach(function (qualifier) {\n            attributes[qualifier.attrName] = true;\n        });\n    });\n\n    return Object.keys(attributes);\n}\n\nvar MutationSummary = (function () {\n    function MutationSummary(opts) {\n        var _this = this;\n        this.connected = false;\n        this.options = MutationSummary.validateOptions(opts);\n        this.observerOptions = MutationSummary.createObserverOptions(this.options.queries);\n        this.root = this.options.rootNode;\n        this.callback = this.options.callback;\n\n        this.elementFilter = Array.prototype.concat.apply([], this.options.queries.map(function (query) {\n            return query.elementFilter ? query.elementFilter : [];\n        }));\n        if (!this.elementFilter.length)\n            this.elementFilter = undefined;\n\n        this.calcReordered = this.options.queries.some(function (query) {\n            return query.all;\n        });\n\n        this.queryValidators = []; // TODO(rafaelw): Shouldn't always define this.\n        if (MutationSummary.createQueryValidator) {\n            this.queryValidators = this.options.queries.map(function (query) {\n                return MutationSummary.createQueryValidator(_this.root, query);\n            });\n        }\n\n        this.observer = new MutationObserverCtor(function (mutations) {\n            _this.observerCallback(mutations);\n        });\n\n        this.reconnect();\n    }\n    MutationSummary.createObserverOptions = function (queries) {\n        var observerOptions = {\n            childList: true,\n            subtree: true\n        };\n\n        var attributeFilter;\n        function observeAttributes(attributes) {\n            if (observerOptions.attributes && !attributeFilter)\n                return;\n\n            observerOptions.attributes = true;\n            observerOptions.attributeOldValue = true;\n\n            if (!attributes) {\n                // observe all.\n                attributeFilter = undefined;\n                return;\n            }\n\n            // add to observed.\n            attributeFilter = attributeFilter || {};\n            attributes.forEach(function (attribute) {\n                attributeFilter[attribute] = true;\n                attributeFilter[attribute.toLowerCase()] = true;\n            });\n        }\n\n        queries.forEach(function (query) {\n            if (query.characterData) {\n                observerOptions.characterData = true;\n                observerOptions.characterDataOldValue = true;\n                return;\n            }\n\n            if (query.all) {\n                observeAttributes();\n                observerOptions.characterData = true;\n                observerOptions.characterDataOldValue = true;\n                return;\n            }\n\n            if (query.attribute) {\n                observeAttributes([query.attribute.trim()]);\n                return;\n            }\n\n            var attributes = elementFilterAttributes(query.elementFilter).concat(query.attributeList || []);\n            if (attributes.length)\n                observeAttributes(attributes);\n        });\n\n        if (attributeFilter)\n            observerOptions.attributeFilter = Object.keys(attributeFilter);\n\n        return observerOptions;\n    };\n\n    MutationSummary.validateOptions = function (options) {\n        for (var prop in options) {\n            if (!(prop in MutationSummary.optionKeys))\n                throw Error('Invalid option: ' + prop);\n        }\n\n        if (typeof options.callback !== 'function')\n            throw Error('Invalid options: callback is required and must be a function');\n\n        if (!options.queries || !options.queries.length)\n            throw Error('Invalid options: queries must contain at least one query request object.');\n\n        var opts = {\n            callback: options.callback,\n            rootNode: options.rootNode || document,\n            observeOwnChanges: !!options.observeOwnChanges,\n            oldPreviousSibling: !!options.oldPreviousSibling,\n            queries: []\n        };\n\n        for (var i = 0; i < options.queries.length; i++) {\n            var request = options.queries[i];\n\n            // all\n            if (request.all) {\n                if (Object.keys(request).length > 1)\n                    throw Error('Invalid request option. all has no options.');\n\n                opts.queries.push({ all: true });\n                continue;\n            }\n\n            // attribute\n            if ('attribute' in request) {\n                var query = {\n                    attribute: validateAttribute(request.attribute)\n                };\n\n                query.elementFilter = Selector.parseSelectors('*[' + query.attribute + ']');\n\n                if (Object.keys(request).length > 1)\n                    throw Error('Invalid request option. attribute has no options.');\n\n                opts.queries.push(query);\n                continue;\n            }\n\n            // element\n            if ('element' in request) {\n                var requestOptionCount = Object.keys(request).length;\n                var query = {\n                    element: request.element,\n                    elementFilter: Selector.parseSelectors(request.element)\n                };\n\n                if (request.hasOwnProperty('elementAttributes')) {\n                    query.attributeList = validateElementAttributes(request.elementAttributes);\n                    requestOptionCount--;\n                }\n\n                if (requestOptionCount > 1)\n                    throw Error('Invalid request option. element only allows elementAttributes option.');\n\n                opts.queries.push(query);\n                continue;\n            }\n\n            // characterData\n            if (request.characterData) {\n                if (Object.keys(request).length > 1)\n                    throw Error('Invalid request option. characterData has no options.');\n\n                opts.queries.push({ characterData: true });\n                continue;\n            }\n\n            throw Error('Invalid request option. Unknown query request.');\n        }\n\n        return opts;\n    };\n\n    MutationSummary.prototype.createSummaries = function (mutations) {\n        if (!mutations || !mutations.length)\n            return [];\n\n        var projection = new MutationProjection(this.root, mutations, this.elementFilter, this.calcReordered, this.options.oldPreviousSibling);\n\n        var summaries = [];\n        for (var i = 0; i < this.options.queries.length; i++) {\n            summaries.push(new Summary(projection, this.options.queries[i]));\n        }\n\n        return summaries;\n    };\n\n    MutationSummary.prototype.checkpointQueryValidators = function () {\n        this.queryValidators.forEach(function (validator) {\n            if (validator)\n                validator.recordPreviousState();\n        });\n    };\n\n    MutationSummary.prototype.runQueryValidators = function (summaries) {\n        this.queryValidators.forEach(function (validator, index) {\n            if (validator)\n                validator.validate(summaries[index]);\n        });\n    };\n\n    MutationSummary.prototype.changesToReport = function (summaries) {\n        return summaries.some(function (summary) {\n            var summaryProps = [\n                'added', 'removed', 'reordered', 'reparented',\n                'valueChanged', 'characterDataChanged'];\n            if (summaryProps.some(function (prop) {\n                return summary[prop] && summary[prop].length;\n            }))\n                return true;\n\n            if (summary.attributeChanged) {\n                var attrNames = Object.keys(summary.attributeChanged);\n                var attrsChanged = attrNames.some(function (attrName) {\n                    return !!summary.attributeChanged[attrName].length;\n                });\n                if (attrsChanged)\n                    return true;\n            }\n            return false;\n        });\n    };\n\n    MutationSummary.prototype.observerCallback = function (mutations) {\n        if (!this.options.observeOwnChanges)\n            this.observer.disconnect();\n\n        var summaries = this.createSummaries(mutations);\n        this.runQueryValidators(summaries);\n\n        if (this.options.observeOwnChanges)\n            this.checkpointQueryValidators();\n\n        if (this.changesToReport(summaries))\n            this.callback(summaries);\n\n        // disconnect() may have been called during the callback.\n        if (!this.options.observeOwnChanges && this.connected) {\n            this.checkpointQueryValidators();\n            this.observer.observe(this.root, this.observerOptions);\n        }\n    };\n\n    MutationSummary.prototype.reconnect = function () {\n        if (this.connected)\n            throw Error('Already connected');\n\n        this.observer.observe(this.root, this.observerOptions);\n        this.connected = true;\n        this.checkpointQueryValidators();\n    };\n\n    MutationSummary.prototype.takeSummaries = function () {\n        if (!this.connected)\n            throw Error('Not connected');\n\n        var summaries = this.createSummaries(this.observer.takeRecords());\n        return this.changesToReport(summaries) ? summaries : undefined;\n    };\n\n    MutationSummary.prototype.disconnect = function () {\n        var summaries = this.takeSummaries();\n        this.observer.disconnect();\n        this.connected = false;\n        return summaries;\n    };\n    MutationSummary.NodeMap = NodeMap;\n    MutationSummary.parseElementFilter = Selector.parseSelectors;\n\n    MutationSummary.optionKeys = {\n        'callback': true,\n        'queries': true,\n        'rootNode': true,\n        'oldPreviousSibling': true,\n        'observeOwnChanges': true\n    };\n    return MutationSummary;\n})();\n\nmodule.exports = MutationSummary"
  ]
}